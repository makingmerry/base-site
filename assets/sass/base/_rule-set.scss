// # rule set
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

// # rule-set($selector, $declarations, $selector-modifier: null)
// 
// Form a rule set by adding declarations to a selector
// 
// @param `string`: $selector: Class name selector
// @param `map`: $declarations: Map containing property to value lines, to declare within selector
// @param `string`: $selector-modifier: Modifier string to attach to end of selector
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
@mixin rule-set($selector, $declarations, $selector-modifier: "") {
  // no modifiers (default)
  @if $selector-modifier == "" {
    .#{$selector} {
      @each $property, $value in $declarations {
        #{$property}: #{$value};
      }
    }
  // modified
  } @else {
    .#{$selector}--#{$selector-modifier} {
      @each $property, $value in $declarations {
        #{$property}: #{$value};
      }
    }
  }
}

// # responsive-rule-set($selector, $declarations)
// 
// Form identical rule sets replicated for varying media sizes
// 
// @param `list`: $selectors: List of class name selectors
// @param `list`: $declarations: List of declaration maps to embed within selectors
// 
// * Number of selectors must match number of declarations
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
@mixin responsive-rule-set($selectors, $declarations) {
  @each $size, $breakpoint in $screen-sizes {
    // base size
    @if $size == 'base' {
      @each $selector in $selectors {
        $i: index($selectors, $selector);
        @include rule-set($selector, nth($declarations, $i));
      }
    // media sizes
    } @else {
      @media (min-width: $breakpoint) {
        @each $selector in $selectors {
          $i: index($selectors, $selector);
          @include rule-set($selector, nth($declarations, $i), $size);
        }
      }
    }
  }
}

// // # order selectors
// // 
// // Returns an ordered list of selector class names
// // Each name has the same prefix, but are indexed in order
// // 
// // @param `string` $prefix: Abbreviations/prefixes for generating selector class names
// // @param `number` $length: List length
// // @param `boolean` $reverse: Ascending(default) or descending order
// // @param `boolean` $zero-index: Start at 1 index(default) or 0
// ////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////
// @function order-selectors($prefix, $length, $reverse: false, $zero-index: false) {
//   $result: ();
//   // ascending order
//   @if $reverse == false {
//     @for $i from 1 through $length {
//       $n: $i;
//       @if ($zero-index == true) { $n: $i - 1; }
//       $result: append($result, #{$prefix}-#{$n}, 'comma'); 
//     }
//   // descending order
//   } @else {
//     @for $i from $length through 1 {
//       $n: $i;
//       @if ($zero-index == true) { $n: $i - 1; }
//       $result: append($result, #{$prefix}-#{$n}, 'comma'); 
//     }
//   }
//   @return $result;
// };

// // # zip declarations
// // 
// // Returns a list of declaration maps
// // Each map contains the same list of properties but allows varied values
// // 
// // @param `list` $properties: List of properties to 'zip' with values
// // @param `list` $value-sets: List of value sets to zip with properties
// // 
// // * Number of items in both lists must match
// ////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////
// @function zip-declarations($properties, $value-sets) {
//   $result: ();
//   $length: length(nth($value-sets, 1));
//   @for $i from 1 through $length {
//     $declarations: ();
//     // match each property with the corresponding value in a set
//     // to form a declaration,
//     // then form a map of declarations if applicable
//     @each $property in $properties {
//       $n: index($properties, $property);
//       $values: nth($value-sets, $n);
//       $declarations: map-merge($declarations, ($property: nth($values, $i)));
//     }
//     $result: append($result, $declarations, 'comma');
//   }
//   @return $result;
// };